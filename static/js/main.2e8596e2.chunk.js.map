{"version":3,"sources":["Graph.js","random_walls.js","App.js","serviceWorker.js","index.js"],"names":["Graph","this","nodes","adjList","node","push","name","node1","node2","weight","startNode","endNode","times","backtrace","pq","visited","forEach","Infinity","sort","a","b","currentNode","shift","isWall","neighbor","time","length","path","lastVisited","unshift","grid","i","j","addNode","undefined","addEdge","error","make_random_grid","start","end","copygrid","counter","is_wall","Math","random","isStart","isEnd","row","col","Grid","props","state","phase","gridState","mouseOverState","weightValue","handleClick","bind","handleChange","handleLongPress","handlePressRelease","handleMouseOver","resetGrid","setState","event","target","value","prev","parseInt","preventDefault","event_element","copied","slice","key","addingWalls","graph","gridtoGraph","result","shortestPath","Promise","resolve","reject","animate","then","success","failure","console","log","resetNodeClass","document","getElementById","className","id","window","setTimeout","clearTimeout","search_path","result_path","promise_array","ms","idx","node_div","animate_search","all","rows","map","element","onClick","onMouseDown","onMouseUp","onMouseOver","StatusTitle","addingWeights","Options","onChange","isErasing","React","Component","Node","node_state","title_string","Boolean","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.2e8596e2.chunk.js","sourcesContent":["export class Graph {\n  constructor() {\n    // nodes are objects with 4 key-value pairs: name, row, col, isWall\n    this.nodes = [];\n    this.adjList = {};\n  }\n\n  addNode(node) {\n    this.nodes.push(node);\n    this.adjList[node.name] = [];\n  }\n\n  addEdge(node1, node2, weight) {\n    // an edge is an object with a node and weight property.\n    //this.adjList[node1.name].push({ node: node2, weight: weight });\n    this.adjList[node2.name].push({ node: node1, weight: weight });\n  }\n\n  shortestPath(startNode, endNode) {\n    // keep track of the shortest total distance from start to each node\n    let times = {};\n    // keeps track of the paths found\n    let backtrace = {};\n    // a priority queue of nodes and their distances\n    let pq = [];\n    // an array of nodes we have visited\n    const visited = [];\n\n    // initialize the start node as having 0 distance\n    times[startNode.name] = 0;\n\n    // all other nodes are initially infinitely far away\n    this.nodes.forEach(node => {\n      if (node.name !== startNode.name) {\n        times[node.name] = Infinity;\n      }\n    });\n\n    pq.push([startNode, 0]);\n    while (pq.length !== 0) {\n      pq.sort((a, b) => (a[1] > b[1] ? 1 : b[1] > a[1] ? -1 : 0));\n\n      // get the closest node\n      let current = pq.shift();\n      let currentNode = current[0];\n\n      if (currentNode.isWall) {\n      } else {\n        // visit this closest node\n        visited.push(currentNode.name);\n        if (currentNode.name === endNode.name) {\n          // we've reached the end\n          break;\n        } else {\n          // conduct edge relaxation on all neighbors\n          this.adjList[currentNode.name].forEach(neighbor => {\n            let time = times[currentNode.name] + neighbor.weight;\n            if (time < times[neighbor.node.name]) {\n              times[neighbor.node.name] = time;\n              backtrace[neighbor.node.name] = currentNode.name;\n              pq.push([neighbor.node, time]);\n            }\n          });\n        }\n      }\n    }\n    // if time to endNode is calculated as infinity, then no path exists from start node to end node\n    // hence path is an returned as an empty array\n    if (times[endNode.name] === Infinity) {\n      return [[], visited];\n    }\n    let path = [endNode.name];\n    let lastVisited = endNode.name;\n    while (lastVisited !== startNode.name) {\n      path.unshift(backtrace[lastVisited]);\n      lastVisited = backtrace[lastVisited];\n    }\n    return [path, visited];\n  }\n\n  gridtoGraph(grid) {\n    for (let i = 0; i < grid.length; i++) {\n      for (let j = 0; j < grid[0].length; j++) {\n        let weight = grid[i][j].weight;\n        this.addNode(grid[i][j]);\n        try {\n          if (grid[i - 1][j] !== undefined) {\n            this.addEdge(grid[i - 1][j], grid[i][j], weight);\n          }\n        } catch (error) {}\n        try {\n          if (grid[i][j - 1] !== undefined) {\n            this.addEdge(grid[i][j - 1], grid[i][j], weight);\n          }\n        } catch (error) {}\n        try {\n          if (grid[i][j + 1] !== undefined) {\n            this.addEdge(grid[i][j + 1], grid[i][j], weight);\n          }\n        } catch (error) {}\n        try {\n          if (grid[i + 1][j] !== undefined) {\n            this.addEdge(grid[i + 1][j], grid[i][j], weight);\n          }\n        } catch (error) {}\n      }\n    }\n  }\n}\n","export function make_random_grid(start, end) {\n  const copygrid = [];\n  let counter = 0;\n  for (let i = 0; i < 25; i++) {\n    copygrid[i] = [];\n    for (let j = 0; j < 35; j++) {\n      var is_wall = Math.random() > 0.7;\n      copygrid[i][j] = {\n        name: counter,\n        isWall: is_wall,\n        isStart: counter === start,\n        isEnd: counter === end,\n        weight: 1,\n        row: i,\n        col: j\n      };\n      counter++;\n    }\n  }\n  return copygrid;\n}\n","import React from \"react\";\nimport \"./App.css\";\nimport { Graph } from \"./Graph.js\";\nimport { make_random_grid } from \"./random_walls.js\";\n\n/** * The main component to display the grid.  */\nclass Grid extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            grid: [],\n            start: {},\n            end: {},\n            phase: 1,\n            gridState: \"normal\",\n            mouseOverState: \"normal\",\n            weightValue: 1\n        };\n\n        this.handleClick = this.handleClick.bind(this);\n        this.handleChange = this.handleChange.bind(this);\n        this.handleLongPress = this.handleLongPress.bind(this);\n        this.handlePressRelease = this.handlePressRelease.bind(this);\n        this.handleMouseOver = this.handleMouseOver.bind(this);\n        this.resetGrid = this.resetGrid.bind(this);\n    }\n\n    /**\n     * Initialize an empty grid of nodes when component mounts.\n     */\n    componentDidMount() {\n        // temporary array to contain the grid\n        const copygrid = [];\n        let counter = 0;\n\n        for (let i = 0; i < 25; i++) {\n            // create an array for each row\n            copygrid[i] = [];\n            for (let j = 0; j < 35; j++) {\n                // create an empty node\n                copygrid[i][j] = {\n                    name: counter,\n                    isWall: false,\n                    isStart: false,\n                    isEnd: false,\n                    weight: 1,\n                    row: i,\n                    col: j\n                };\n                counter++;\n            }\n        }\n\n        // set the empty grid created to be the current state\n        this.setState({\n            grid: copygrid\n        });\n    }\n\n    /**\n     * Handles events when buttons in the Options component below the grid are clicked.\n     * @param {event} event The event fired by the click on button.\n     */\n    handleChange(event) {\n        // get the button that was clicked\n        const { name, value } = event.target;\n\n        if (\n            name === \"addingWalls\" ||\n            name === \"addingWeights\" ||\n            name === \"eraseButton\"\n        ) {\n            // reset the gridState if we are alr in one of these modes. Else change\n            // to that mode.\n            this.setState(prev => ({\n                gridState: prev.gridState === name ? \"normal\" : name,\n                mouseOverState: \"normal\"\n            }));\n        } else if (name === \"resetButton\") {\n            this.resetGrid();\n        } else if (name === \"weightSelector\") {\n            // weightValue state keeps track of what weight we are curr adding\n            this.setState({\n                weightValue: parseInt(value)\n            });\n        } else if (name === \"randomButton\") {\n            // replace the curr grid state with a new randomized grid\n            this.setState({\n                grid: make_random_grid(\n                    this.state.start.name,\n                    this.state.end.name\n                )\n            });\n        }\n    }\n\n    /**\n     * Handles the activation of \"drawing\" mode.\n     * @param {event} event The longpress event on any node.\n     */\n    handleLongPress(event) {\n        // prevent the default dragging behaviour\n        event.preventDefault();\n\n        // update the mouseOver state depending on what we are drawing\n        if (this.state.gridState === \"addingWalls\") {\n            this.setState({ mouseOverState: \"drawingWalls\" });\n        } else if (this.state.gridState === \"addingWeights\") {\n            this.setState({ mouseOverState: \"drawingWeights\" });\n        } else if (this.state.gridState === \"eraseButton\") {\n            this.setState({ mouseOverState: \"erasing\" });\n        }\n    }\n\n    /**\n     * Resets the mouseOver state once we lift the mouse button after drawing\n     */\n    handlePressRelease() {\n        this.setState({\n            mouseOverState: \"normal\"\n        });\n    }\n\n    /**\n     * Draws on the grid as user click and drags.\n     * @param {event} event The mouseover event when the cursor enters the div of\n     * the node.\n     * @returns {function} A function that takes in the Node obj stored in each node.\n     */\n    handleMouseOver(event) {\n        event.preventDefault();\n\n        // We want to update the node obj associated with the div that fired the\n        // event.\n        return event_element => {\n            // make a copy of our current grid state to work on.\n            const copied = this.state.grid.slice();\n\n            // check what drawing mode we are in\n            if (this.state.mouseOverState === \"drawingWalls\") {\n                // mark the node moused-over as a wall\n                copied[event_element.row][event_element.col].isWall = true;\n            } else if (this.state.mouseOverState === \"drawingWeights\") {\n                // update the moused-over node's weight\n                copied[event_element.row][\n                    event_element.col\n                ].weight = this.state.weightValue;\n            } else if (this.state.mouseOverState === \"erasing\") {\n                // reset both the weight and wall states of the node\n                copied[event_element.row][event_element.col].weight = 1;\n                copied[event_element.row][event_element.col].isWall = false;\n            }\n\n            // update with the new grid\n            this.setState({\n                grid: copied\n            });\n        };\n    }\n\n    /**\n     * Handles any mouse clicks anywhere on the grid (at any node).\n     * @param {Object} The node obj associated with the clicked div.\n     */\n    handleClick(key) {\n        if (this.state.gridState === \"addingWalls\") {\n            /*  If the user is in \"Add Walls\" mode, allow the user to paint\n             *  individual nodes by clicking on them.\n             */\n            const copied = this.state.grid.slice();\n            copied[key.row][key.col].isWall = true;\n            this.setState({ grid: copied });\n        } else if (this.state.gridState === \"addingWeights\") {\n            /*  If the user is in \"Add Weights\" mode, allow the user to paint\n             *  individual nodes by clicking on them.\n             */\n            const copied = this.state.grid.slice();\n            copied[key.row][key.col].weight = this.state.weightValue;\n            this.setState({ grid: copied });\n        } else if (this.state.gridState === \"eraseButton\") {\n            /*  If the user is in \"Erase\" mode, allow the user to erase\n             *  individual nodes by clicking on them.\n             */\n            const copied = this.state.grid.slice();\n\n            // reset these properties of the node object\n            copied[key.row][key.col].weight = 1;\n            copied[key.row][key.col].isWall = false;\n            this.setState({ grid: copied });\n        } else {\n            // Else, the user is trying to select a start/end node, or ready to start\n            // the search algorithm.\n            if (this.state.phase === 1) {\n                // set the starting node\n                const copied = this.state.grid.slice();\n                copied[key.row][key.col].isStart = true;\n                this.setState({\n                    grid: copied,\n                    start: copied[key.row][key.col],\n                    // increment to the next phase to add the end node\n                    phase: 2\n                });\n            } else if (this.state.phase === 2) {\n                // set the end node\n                const copied = this.state.grid.slice();\n                copied[key.row][key.col].isEnd = true;\n                this.setState({\n                    grid: copied,\n                    end: copied[key.row][key.col],\n                    // increment to next phase to start the algo\n                    phase: 3\n                });\n            } else {\n                // start Dijkstra's Algorithm\n                if (!this.state.addingWalls) {\n                    // create a new Graph instance\n                    const graph = new Graph();\n\n                    // read the current grid into the graph\n                    graph.gridtoGraph(this.state.grid);\n\n                    // find the shortest path\n                    const result = graph.shortestPath(\n                        this.state.start,\n                        this.state.end\n                    );\n\n                    if (!result[0].length) {\n                        // if there was no result found, create a promise to wait for the\n                        // searching animation to complete\n                        const noPath = new Promise((resolve, reject) => {\n                            resolve(this.animate(result));\n                            reject(\"error\");\n                        });\n\n                        // After the searching animation is done, increment the phase\n                        // reflect that no result was found.\n                        noPath.then(\n                            success => {\n                                if (success) {\n                                    this.setState({\n                                        phase: 4\n                                    });\n                                }\n                            },\n                            failure => {\n                                console.log(failure);\n                            }\n                        );\n                    }\n\n                    // render the search animation\n                    this.animate(result);\n                } else {\n                }\n            }\n        }\n    }\n\n    /**\n     * This function resets the entire state of the search grid and algorithm.\n     * It is called when the user presses the reset button.\n     */\n    resetGrid() {\n        // Create a new empty grid as in ComponentDidMount\n        const copygrid = [];\n        let counter = 0;\n        for (let i = 0; i < 25; i++) {\n            copygrid[i] = [];\n            for (let j = 0; j < 35; j++) {\n                copygrid[i][j] = {\n                    name: counter,\n                    isWall: false,\n                    row: i,\n                    col: j,\n                    weight: 1\n                };\n                resetNodeClass(counter);\n                counter++;\n            }\n        }\n\n        // This function resets the class of the give node (by id) to .Node\n        // It is used to un-color colored nodes.\n        function resetNodeClass(value) {\n            var node_div = document.getElementById(value);\n            node_div.className = \"Node\";\n        }\n\n        // Stop all animations\n        var id = window.setTimeout(function() {}, 0);\n\n        // This hack works bc timer IDs are consecutive integers. So we just need\n        // to get the latest timer id and decrement from it to get all timers.\n        while (id--) {\n            window.clearTimeout(id);\n        }\n\n        // Reset the reset of the grid state\n        this.setState({\n            grid: copygrid,\n            phase: 1,\n            start: {},\n            end: {},\n            gridState: \"normal\",\n            mouseOverState: \"normal\",\n            weightValue: 1\n        });\n    }\n\n    /** This is the main animation function.\n     *  It animates both the search path and result path found by Dijkstra's\n     *  Algo.\n     *\n     *  @param {Array<number[]>} an array where idx=0 is the search path and\n     *  idx=1 is the result path.\n     *  @return {undefined} this function does not return a value\n     */\n    animate(result) {\n        const search_path = result[1];\n        const result_path = result[0];\n\n        // function wait is a promise wrapper for setTimeout.\n        // it has the same functionality as setTimeout, but also returns a promise.\n        const wait = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n        // Array to store promises returned from animating the\n        // search path\n        const promise_array = [];\n\n        /** Colors the node specified in the search_path as visited.\n         *  @param {number} The current index of the search_path array being\n         *  animated.\n         */\n        function animate_search(idx) {\n            var node_div = document.getElementById(search_path[idx]);\n            if (\n                node_div.className !== \"Start\" &&\n                node_div.className !== \"End\"\n            ) {\n                node_div.className = \"Visited\";\n            } else {\n            }\n        }\n\n        /**\n         * Animates the result path that Dijkstra's Algo found.\n         */\n        function animate_result() {\n            // begin iterating through the result path found\n            for (let i = 0; i < result_path.length; i++) {\n                setTimeout(() => {\n                    var node_div = document.getElementById(result_path[i]);\n                    if (\n                        node_div.className === \"Start\" ||\n                        node_div.className === \"End\"\n                    ) {\n                    } else {\n                        node_div.className = \"Path\";\n                    }\n                }, 50 * i);\n            }\n        }\n\n        // start animating the search path\n        for (let i = 0; i < search_path.length; i++) {\n            // for each node we animate, wrap it in the wait promise wrapper, then\n            // push it to an array of promises.\n            promise_array.push(wait(10 * i).then(() => animate_search(i)));\n        }\n\n        // After validating that all promises have been fulfilled (which means we\n        // are done animating the search path), start animating the result path\n        return Promise.all(promise_array)\n            .then(animate_result)\n            .then(() => true);\n    }\n\n    render() {\n        const rows = this.state.grid.map(row => (\n            <div className=\"RowContainer\">\n                {row.map(element => (\n                    <Node\n                        key={element.name}\n                        element={element}\n                        onClick={this.handleClick}\n                        onMouseDown={this.handleLongPress}\n                        onMouseUp={this.handlePressRelease}\n                        onMouseOver={this.handleMouseOver}\n                    />\n                ))}\n            </div>\n        ));\n\n        return (\n            <div className=\"GameContainer\">\n                <StatusTitle\n                    addingWalls={this.state.addingWalls}\n                    addingWeights={this.state.addingWeights}\n                    phase={this.state.phase}\n                />\n                {rows}\n                <Options\n                    addingWalls={this.state.gridState === \"addingWalls\"}\n                    onChange={this.handleChange}\n                    addingWeights={this.state.gridState === \"addingWeights\"}\n                    isErasing={this.state.gridState === \"eraseButton\"}\n                />\n            </div>\n        );\n    }\n}\n\nclass Node extends React.Component {\n    render() {\n        let node_state;\n\n        // this.props.element is the Node object of the component\n        if (this.props.element.isStart) {\n            node_state = \"Start\";\n        } else if (this.props.element.isEnd) {\n            node_state = \"End\";\n        } else if (this.props.element.isWall) {\n            node_state = \"Wall\";\n        } else {\n            node_state = \"Node\";\n        }\n\n        return (\n            <div\n                className={node_state}\n                onClick={() => this.props.onClick(this.props.element)}\n                id={this.props.element.name}\n                onMouseDown={this.props.onMouseDown}\n                onMouseUp={this.props.onMouseUp}\n                onMouseOver={event =>\n                    this.props.onMouseOver(event)(this.props.element)\n                }\n            >\n                {this.props.element.weight > 1 &&\n                !this.props.element.isEnd &&\n                !this.props.element.isStart ? (\n                    <span> {this.props.element.weight} </span>\n                ) : (\n                    <span className=\"HideThis\"> 1 </span>\n                )}\n            </div>\n        );\n    }\n}\n\nfunction Options(props) {\n    return (\n        <div className=\"Options\">\n            <button onClick={props.onChange} name=\"addingWalls\">\n                {props.addingWalls ? \"Done\" : \"Add Walls\"}\n            </button>\n            <button onClick={props.onChange} name=\"resetButton\">\n                Reset\n            </button>\n            <button onClick={props.onChange} name=\"eraseButton\">\n                {props.isErasing ? \"Done\" : \"Erase\"}\n            </button>\n            <button onClick={props.onChange} name=\"addingWeights\">\n                {props.addingWeights ? \"Done\" : \"Add Weights\"}\n            </button>\n            {props.addingWeights ? (\n                <select onChange={props.onChange} name=\"weightSelector\">\n                    <option value=\"1\"> 1 </option>\n                    <option value=\"2\"> 2 </option>\n                    <option value=\"3\"> 3 </option>\n                    <option value=\"4\"> 4 </option>\n                </select>\n            ) : null}\n            <button onClick={props.onChange} name=\"randomButton\">\n                Randomize walls\n            </button>\n        </div>\n    );\n}\n\nfunction StatusTitle(props) {\n    /*  This component displays the current phase to the user.\n     *  The user can either be choosing a start node, end node, drawing walls, or\n     *  be prompted to start the algorithm.\n     *\n     *  { StatusTitle.props.addingWalls } Predicate to check if user is drawing\n     *  walls.\n     *\n     *  { StatusTitle.props.phase } Number to track whether the user is setting\n     *  start/end nodes or ready to start the algorithm.\n     */\n\n    let title_string;\n\n    if (props.addingWalls) {\n        title_string = \"Click and hold to draw walls on the grid\";\n    } else if (props.addingWeights) {\n        title_string = \"Click and hold to add weights on the grid\";\n    } else if (props.phase === 1) {\n        title_string = \"Click to choose the starting node\";\n    } else if (props.phase === 2) {\n        title_string = \"Click to choose the end node\";\n    } else if (props.phase === 4) {\n        title_string = \"No path found!\";\n    } else {\n        title_string =\n            \"Click anywhere on the grid to start the search algorithm\";\n    }\n\n    return <h1 className=\"StatusTitle\">{title_string}</h1>;\n}\n\nexport default Grid;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}